import streamlit as st
import time
import os
import shutil
import subprocess
import signal
import csv

st.set_page_config(page_title="Domain Verifier", layout="centered")
st.title("Domain Verifier")

# Description/instructions
st.markdown(
    """
    <div style='margin-bottom: 20px; font-size: 16px;'>
    <b>Instructions:</b><br>
    1. Upload your domain list as a CSV file with a header named Domain<br>
    2. Indicate how many times you want the domain list to be processed.<br>
    3. Click <b>Start</b> to begin processing. You can stop anytime with the <b>Stop</b> button.<br>
    4. When processing is complete, click <b>Download Result</b> to download your processed file.
    </div>
    """,
    unsafe_allow_html=True,
)

# Upload section
uploaded_file = st.file_uploader("Upload CSV file", type=["csv"])

# Save uploaded file to upload folder
upload_path = None
if uploaded_file is not None:
    upload_dir = "upload"
    os.makedirs(upload_dir, exist_ok=True)
    upload_path = os.path.join(upload_dir, uploaded_file.name)
    with open(upload_path, "wb") as f:
        f.write(uploaded_file.getbuffer())
    st.success(f"File uploaded to {upload_path}")

# Number input for processing times
num_times = st.number_input("How many times to process the file?", min_value=1, max_value=100, value=4)

# Determine max_domains from uploaded CSV
max_domains = 0
if upload_path and os.path.exists(upload_path):
    with open(upload_path, newline='', encoding='utf-8') as csvfile:
        reader = csv.reader(csvfile)
        header = next(reader, None)
        for _ in reader:
            max_domains += 1

# Start button (full width, green)
start = st.button(
    "Start",
    key="start_btn",
    help="Start processing",
    use_container_width=True,
)

# State for process
if 'process_running' not in st.session_state:
    st.session_state['process_running'] = False
if 'process_finished' not in st.session_state:
    st.session_state['process_finished'] = False
if 'process_pid' not in st.session_state:
    st.session_state['process_pid'] = None

# Require upload before starting
if start and not upload_path:
    st.warning("Please upload a CSV file before starting the process.")

# When Start is clicked, run verify_websites.py with correct arguments
if start and upload_path and not st.session_state.get('process_running', False):
    st.session_state['process_finished'] = False
    st.session_state['process_pid'] = None
    st.info("Processing... Please wait.")
    import sys
    script_path = os.path.abspath("verify_websites.py")
    command = [sys.executable, script_path, upload_path, "--retries", str(num_times)]
    try:
        # Run in the same terminal as Streamlit (no creationflags)
        process = subprocess.Popen(command)
        st.session_state['process_pid'] = process.pid
        st.session_state['process_running'] = True
    except Exception as e:
        st.error(f"Failed to start verification process: {e}\nCommand: {' '.join(command)}")

# Row with Stop and Download Result buttons (50% each)
col_stop, col_download = st.columns(2)
with col_stop:
    stop_enabled = st.session_state.get('process_running', False)
    stop = st.button(
        "Stop",
        key="stop_btn",
        help="Stop processing",
        use_container_width=True,
        disabled=not stop_enabled
    )
    if stop and st.session_state.get('process_pid'):
        try:
            import signal
            os.kill(st.session_state['process_pid'], signal.SIGTERM)
            st.session_state['process_running'] = False
            st.session_state['process_pid'] = None
            st.warning("Process stopped by user.")
        except Exception as e:
            st.error(f"Failed to stop process: {e}")

# Wait for process to finish, update state
# Removed psutil-based process monitoring as psutil is not installed and not required
# You may want to implement a different way to check if the process is done, or rely on process return codes if needed
if st.session_state.get('process_running', False) and st.session_state.get('process_pid'):
    try:
        # Fallback: check if process is still running by PID
        try:
            os.kill(st.session_state['process_pid'], 0)
        except OSError:
            st.session_state['process_running'] = False
            st.session_state['process_finished'] = True
            st.session_state['process_pid'] = None
            st.success("Processing complete!")
    except Exception:
        pass

# Move output files if process finished
if st.session_state.get('process_finished', False) and upload_path:
    base_name = os.path.splitext(os.path.basename(upload_path))[0]
    reachable_file = f"{base_name}_reachable.csv"
    all_file = f"{base_name}_report_all.csv"
    if os.path.exists(reachable_file):
        shutil.move(reachable_file, os.path.join("reachable", reachable_file))
    if os.path.exists(all_file):
        shutil.move(all_file, os.path.join("all", all_file))

# Progress bar section (dummy data for demo)
progress = 0.65  # 65% done
current = 65
max_domains = 100
progress_bar = st.progress(progress)

# Progress bar indicators
col_left, col_right = st.columns([1, 1])
with col_left:
    st.markdown(f"<span style='font-size: 16px;'>{int(progress*100)}%</span>", unsafe_allow_html=True)
with col_right:
    st.markdown(f"<span style='font-size: 16px; float: right;'>{current}/{max_domains}</span>", unsafe_allow_html=True)

with col_download:
    # Download the latest reachable result if available
    from glob import glob
    import pathlib
    download_file = None
    download_enabled = False
    latest_file = None
    reachable_files = glob(os.path.join("reachable", "*_reachable.csv"))
    if reachable_files:
        latest_file = max(reachable_files, key=os.path.getmtime)
        with open(latest_file, "rb") as f:
            download_file = f.read()
        download_enabled = st.session_state.get('process_finished', False)
    st.download_button(
        label="Download Result",
        data=download_file if download_file else "domain,verified\nexample.com,True\nexample2.com,False",
        file_name=pathlib.Path(latest_file).name if latest_file else "verified_domains.csv",
        mime="text/csv",
        help="Download the processed result after completion.",
        use_container_width=True,
        disabled=not download_enabled
    )

# Display results table if available
import pandas as pd
base_name = os.path.splitext(os.path.basename(upload_path))[0] if upload_path else None
reachable_file = os.path.join("reachable", f"{base_name}_reachable.csv") if base_name else None
if reachable_file and os.path.exists(reachable_file):
    try:
        df = pd.read_csv(reachable_file)
        st.subheader("Reachable Domains Result Preview")
        st.dataframe(df.head(20))
    except Exception as e:
        st.warning(f"Could not read result file: {e}")

# Only auto-refresh if process is still running and Start button was not just pressed
if st.session_state.get('process_running', False) and not start:
    time.sleep(3)
    if callable(getattr(st, 'experimental_rerun', None)):
        st.experimental_rerun()

# Optionally, show a message for demo
# st.info("This is a demo. Progress and numbers are dummy data.")